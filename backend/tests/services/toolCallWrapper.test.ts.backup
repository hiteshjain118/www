// Mock dependencies
jest.mock('../../src/qbo/qbDataSchemaRetriever');
jest.mock('../../src/qbo/qbDataSizeRetriever');
jest.mock('../../src/qbo/qbUserDataRetriever');

// Mock coralbricks-common with manual mock
jest.mock('coralbricks-common');

import { Response } from 'express';
import { AxiosError } from 'axios';
import { IToolCall, ToolCallResult, TaskService, TaskStatus } from "coralbricks-common";
import { QueryType } from 'coralbricks-common';
import { TCWrapperBackend, TOOL_REGISTRY } from '../../src/services/tcWrapperBackend';
import { QBProfile } from '../../src/types/profiles';
import { QBDataSchemaRetriever } from '../../src/qbo/qbDataSchemaRetriever';
import { QBDataSizeRetriever } from '../../src/qbo/qbDataSizeRetriever';
import { QBUserDataRetriever } from '../../src/qbo/qbUserDataRetriever';
import { enhancedLogger } from '../../src/utils/logger';

// Get access to the mock
const coralbricksCommonMock = jest.requireMock('coralbricks-common');
const mockTaskService = coralbricksCommonMock.__mockTaskService;

const MockedQBDataSchemaRetriever = QBDataSchemaRetriever as jest.MockedClass<typeof QBDataSchemaRetriever>;
const MockedQBDataSizeRetriever = QBDataSizeRetriever as jest.MockedClass<typeof QBDataSizeRetriever>;
const MockedQBUserDataRetriever = QBUserDataRetriever as jest.MockedClass<typeof QBUserDataRetriever>;

describe('TCWrapperBackend', () => {
  let mockQBOProfile: QBProfile;
  let mockResponse: Partial<Response>;

  beforeEach(() => {
    // Clear mock constructors and instances
    MockedQBDataSchemaRetriever.mockClear();
    MockedQBDataSizeRetriever.mockClear();
    MockedQBUserDataRetriever.mockClear();
    
    // Clear mock call counts, but not implementations
    if (mockTaskService) {
      mockTaskService.createTask.mockClear();
      mockTaskService.updateTaskStatus.mockClear();
    }
    
    // Reset mock implementations
    if (mockTaskService && mockTaskService.createTask) {
      mockTaskService.createTask.mockResolvedValue({
        cbId: BigInt(456),
        handleForModel: 'TestTable_abc123'
      });
      mockTaskService.updateTaskStatus.mockResolvedValue(undefined);
    }
    
    mockQBOProfile = {
      cbId: BigInt(1),
      ownerId: BigInt(1),
      realmId: 'test-realm',
      accessToken: 'test-access-token',
      refreshToken: 'test-refresh-token',
      expiresIn: 3600,
      refreshTokenExpiresIn: 7200,
      isSandbox: true,
      updatedAt: new Date(),
      viewer_context: { cbid: BigInt(1) },
      platform: 'qbo' as any,
      get_base_url: jest.fn().mockReturnValue('https://sandbox-quickbooks.api.intuit.com/v3/company/test-realm')
    } as any;

    mockResponse = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn()
    };

    // Setup mocks
    MockedQBDataSchemaRetriever.mockImplementation(() => ({
      validate: jest.fn().mockResolvedValue(undefined),
      call_tool: jest.fn().mockResolvedValue(ToolCallResult.success('qb_data_schema_retriever', { test: 'data' }, 'test-tool-call-id', BigInt(123))),
      getBlobPath: jest.fn().mockReturnValue('test-blob-path'),
      getModelHandleName: jest.fn().mockReturnValue('TestTable_abc123')
    } as any));

    MockedQBDataSizeRetriever.mockImplementation(() => ({
      validate: jest.fn().mockResolvedValue(undefined),
      call_tool: jest.fn().mockResolvedValue(ToolCallResult.success('qb_data_size_retriever', { count: 5 }, 'test-tool-call-id', BigInt(123))),
      getBlobPath: jest.fn().mockReturnValue('test-blob-path'),
      getModelHandleName: jest.fn().mockReturnValue('TestTable_abc123')
    } as any));

    MockedQBUserDataRetriever.mockImplementation(() => ({
      validate: jest.fn().mockResolvedValue(undefined),
      call_tool: jest.fn().mockResolvedValue(ToolCallResult.success('qb_user_data_retriever', { data: [] }, 'test-tool-call-id', BigInt(123))),
      getBlobPath: jest.fn().mockReturnValue('test-blob-path'),
      getModelHandleName: jest.fn().mockReturnValue('TestTable_abc123')
    } as any));
  });

  describe('constructor', () => {
    it('should initialize with correct thread_id and qboProfile', () => {
      const wrapper = new TCWrapperBackend(BigInt(123), mockQBOProfile);
      expect(wrapper).toBeInstanceOf(TCWrapperBackend);
    });
  });

  describe('run method', () => {
    it('should handle successful tool execution', async () => {
      const wrapper = new TCWrapperBackend(BigInt(123), mockQBOProfile);
      
      await wrapper.run(
        'test-tool-call-id',
        { query: 'test query' },
        'qb_data_size_retriever',
        QueryType.RETRIEVE,
        1,
        mockResponse
      );

      expect(mockResponse.status).toHaveBeenCalledWith(200);
      expect(mockResponse.json).toHaveBeenCalled();
    });

    it('should handle tool execution errors', async () => {
      MockedQBDataSizeRetriever.mockImplementation(() => ({
        validate: jest.fn().mockRejectedValue(new Error('Validation failed')),
        call_tool: jest.fn(),
        getBlobPath: jest.fn().mockReturnValue('test-blob-path'),
        getModelHandleName: jest.fn().mockReturnValue('TestTable_abc123')
      } as any));

      const wrapper = new TCWrapperBackend(BigInt(123), mockQBOProfile);
      
      await wrapper.run(
        'test-tool-call-id',
        { query: 'test' },
        'qb_data_size_retriever',
        QueryType.RETRIEVE,
        1,
        mockResponse
      );

      expect(mockResponse.status).toHaveBeenCalledWith(500);
      expect(mockResponse.json).toHaveBeenCalled();
    });
  });

  describe('wrap method', () => {
    it('should handle RETRIEVE query type', async () => {
      try {
        console.log('Tool instance: 111');

        const wrapper = new TCWrapperBackend(BigInt(123), mockQBOProfile);
        console.log('Tool instance:222');

        
        // Check that getToolInstance works
        const toolInstance = wrapper.getToolInstance('test-tool-call-id', 'qb_data_size_retriever', { query: 'test' });
        console.log('Tool instance:', toolInstance);
        console.log('Tool instance call_tool:', await toolInstance.call_tool());
        
        const result = await wrapper.wrap(
          'test-tool-call-id',
          { query: 'test' },
          'qb_data_size_retriever',
          QueryType.RETRIEVE
        );

        console.log('Result:', result);
        expect(result).toBeDefined();
        expect(result.status).toBe('success');
      } catch (error) {
        console.error('Error in test:', error);
        throw error;
      }
    });

    it('should handle VALIDATE query type', async () => {
      const wrapper = new TCWrapperBackend(BigInt(123), mockQBOProfile);
      
      const result = await wrapper.wrap(
        'test-tool-call-id',
        { table_name: 'test_table' },
        'qb_data_schema_retriever',
        QueryType.VALIDATE
      );

      expect(result.status).toBe('success');
    });

    it('should handle SCHEDULE query type with task creation', async () => {
      const wrapper = new TCWrapperBackend(BigInt(123), mockQBOProfile);
      
      const result = await wrapper.wrap(
        'test-tool-call-id',
        { query: 'test query' },
        'qb_data_size_retriever',
        QueryType.SCHEDULE
      );

      expect(result.status).toBe('scheduled');
      expect(mockTaskService.createTask).toHaveBeenCalled();
    });

    it('should handle SCHEDULE query type with custom delay', async () => {
      const wrapper = new TCWrapperBackend(BigInt(123), mockQBOProfile);
      
      const result = await wrapper.wrap(
        'test-tool-call-id',
        { query: 'test query' },
        'qb_data_size_retriever',
        QueryType.SCHEDULE,
        100 // 100ms delay
      );

      expect(result.status).toBe('scheduled');
    });

    it('should handle scheduled task completion', async () => {
      jest.useFakeTimers();
      
      const wrapper = new TCWrapperBackend(BigInt(123), mockQBOProfile);
      
      // Start the scheduled task
      const resultPromise = wrapper.wrap(
        'test-tool-call-id',
        { query: 'test query' },
        'qb_data_size_retriever',
        QueryType.SCHEDULE,
        1 // 1ms delay
      );

      // Wait for the initial result
      const result = await resultPromise;
      expect(result.status).toBe('scheduled');

      // Fast-forward time to trigger the scheduled execution
      jest.advanceTimersByTime(10);
      
      // Allow promises to resolve
      await new Promise(resolve => setImmediate(resolve));

      expect(mockTaskService.updateTaskStatus).toHaveBeenCalledWith(BigInt(456), TaskStatus.COMPLETED);
      
      jest.useRealTimers();
    });

    it('should handle validation errors gracefully', async () => {
      MockedQBDataSizeRetriever.mockImplementation(() => ({
        validate: jest.fn().mockRejectedValue(new AxiosError('Network error')),
        call_tool: jest.fn(),
        getBlobPath: jest.fn().mockReturnValue('test-blob-path'),
        getModelHandleName: jest.fn().mockReturnValue('TestTable_abc123')
      } as any));

      const wrapper = new TCWrapperBackend(BigInt(123), mockQBOProfile);
      
      const result = await wrapper.wrap(
        'test-tool-call-id',
        { query: 'test' },
        'qb_data_size_retriever',
        QueryType.RETRIEVE
      );

      expect(result.status).toBe('error');
      expect(result.error_type).toBe('AxiosError');
    });

    it('should handle non-axios errors', async () => {
      MockedQBDataSizeRetriever.mockImplementation(() => ({
        validate: jest.fn().mockRejectedValue(new Error('Generic error')),
        call_tool: jest.fn(),
        getBlobPath: jest.fn().mockReturnValue('test-blob-path'),
        getModelHandleName: jest.fn().mockReturnValue('TestTable_abc123')
      } as any));

      const wrapper = new TCWrapperBackend(BigInt(123), mockQBOProfile);
      
      const result = await wrapper.wrap(
        'test-tool-call-id',
        { query: 'test' },
        'qb_data_size_retriever',
        QueryType.RETRIEVE
      );

      expect(result.status).toBe('error');
      expect(result.error_type).toBe('Error');
    });

    it('should handle unknown errors', async () => {
      MockedQBDataSizeRetriever.mockImplementation(() => ({
        validate: jest.fn().mockRejectedValue('String error'),
        call_tool: jest.fn(),
        getBlobPath: jest.fn().mockReturnValue('test-blob-path'),
        getModelHandleName: jest.fn().mockReturnValue('TestTable_abc123')
      } as any));

      const wrapper = new TCWrapperBackend(BigInt(123), mockQBOProfile);
      
      const result = await wrapper.wrap(
        'test-tool-call-id',
        { query: 'test' },
        'qb_data_size_retriever',
        QueryType.RETRIEVE
      );

      expect(result.status).toBe('error');
      expect(result.error_type).toBe('UnknownError');
    });
  });

  describe('getToolInstance', () => {
    it('should create QBDataSizeRetriever instance', () => {
      const wrapper = new TCWrapperBackend(BigInt(123), mockQBOProfile);
      
      const instance = wrapper.getToolInstance(
        'test-tool-call-id',
        'qb_data_size_retriever',
        { query: 'test query' }
      );

      expect(MockedQBDataSizeRetriever).toHaveBeenCalledWith(
        mockQBOProfile,
        BigInt(123),
        'test-tool-call-id',
        'test query'
      );
    });

    it('should throw error for missing query parameter in QBDataSizeRetriever', () => {
      const wrapper = new TCWrapperBackend(BigInt(123), mockQBOProfile);
      
      expect(() => wrapper.getToolInstance(
        'test-tool-call-id',
        'qb_data_size_retriever',
        {}
      )).toThrow('Missing required parameter for qb_data_size_retriever: query');
    });

    it('should create QBDataSchemaRetriever instance', () => {
      const wrapper = new TCWrapperBackend(BigInt(123), mockQBOProfile);
      
      const instance = wrapper.getToolInstance(
        'test-tool-call-id',
        'qb_data_schema_retriever',
        { table_name: 'test_table' }
      );

      expect(MockedQBDataSchemaRetriever).toHaveBeenCalledWith(
        mockQBOProfile,
        BigInt(123),
        'test-tool-call-id',
        'test_table'
      );
    });

    it('should throw error for missing table_name parameter in QBDataSchemaRetriever', () => {
      const wrapper = new TCWrapperBackend(BigInt(123), mockQBOProfile);
      
      expect(() => wrapper.getToolInstance(
        'test-tool-call-id',
        'qb_data_schema_retriever',
        {}
      )).toThrow('Missing required parameter for qb_data_schema_retriever: table_name');
    });

    it('should create QBUserDataRetriever instance', () => {
      const wrapper = new TCWrapperBackend(BigInt(123), mockQBOProfile);
      
      const instance = wrapper.getToolInstance(
        'test-tool-call-id',
        'qb_user_data_retriever',
        {
          endpoint: 'query',
          parameters: { query: 'SELECT * FROM Invoice' },
          expected_row_count: 10
        }
      );

      expect(MockedQBUserDataRetriever).toHaveBeenCalledWith(
        mockQBOProfile,
        BigInt(123),
        'test-tool-call-id',
        'query',
        { query: 'SELECT * FROM Invoice' },
        10
      );
    });

    it('should throw error for missing endpoint in QBUserDataRetriever', () => {
      const wrapper = new TCWrapperBackend(BigInt(123), mockQBOProfile);
      
      expect(() => wrapper.getToolInstance(
        'test-tool-call-id',
        'qb_user_data_retriever',
        {
          parameters: { query: 'SELECT * FROM Invoice' },
          expected_row_count: 10
        }
      )).toThrow('Missing required parameters for qb_user_data_retriever: endpoint, parameters, expected_row_count');
    });

    it('should throw error for missing parameters in QBUserDataRetriever', () => {
      const wrapper = new TCWrapperBackend(BigInt(123), mockQBOProfile);
      
      expect(() => wrapper.getToolInstance(
        'test-tool-call-id',
        'qb_user_data_retriever',
        {
          endpoint: 'query',
          expected_row_count: 10
        }
      )).toThrow('Missing required parameters for qb_user_data_retriever: endpoint, parameters, expected_row_count');
    });

    it('should throw error for missing expected_row_count in QBUserDataRetriever', () => {
      const wrapper = new TCWrapperBackend(BigInt(123), mockQBOProfile);
      
      expect(() => wrapper.getToolInstance(
        'test-tool-call-id',
        'qb_user_data_retriever',
        {
          endpoint: 'query',
          parameters: { query: 'SELECT * FROM Invoice' }
        }
      )).toThrow('Missing required parameters for qb_user_data_retriever: endpoint, parameters, expected_row_count');
    });

    it('should create QBUserDataRetriever with all required parameters', () => {
      const wrapper = new TCWrapperBackend(BigInt(123), mockQBOProfile);
      
      const instance = wrapper.getToolInstance(
        'test-tool-call-id',
        'qb_user_data_retriever',
        {
          endpoint: 'query',
          parameters: { query: 'SELECT * FROM Invoice' },
          expected_row_count: 25
        }
      );

      expect(MockedQBUserDataRetriever).toHaveBeenCalledWith(
        mockQBOProfile,
        BigInt(123),
        'test-tool-call-id',
        'query',
        { query: 'SELECT * FROM Invoice' },
        25
      );
    });

    it('should throw error for unknown tool', () => {
      const wrapper = new TCWrapperBackend(BigInt(123), mockQBOProfile);
      
      expect(() => wrapper.getToolInstance(
        'test-tool-call-id',
        'unknown_tool' as any,
        {}
      )).toThrow('Tool implementation not found');
    });
  });

  describe('TOOL_REGISTRY', () => {
    it('should contain all expected tools', () => {
      expect(TOOL_REGISTRY).toHaveProperty('qb_data_size_retriever');
      expect(TOOL_REGISTRY).toHaveProperty('qb_data_schema_retriever');
      expect(TOOL_REGISTRY).toHaveProperty('qb_user_data_retriever');
    });
  });

  describe('integration tests', () => {
    it('should handle complete workflow for data size retriever', async () => {
      const wrapper = new TCWrapperBackend(BigInt(123), mockQBOProfile);
      
      await wrapper.run(
        'test-tool-call-id',
        { query: 'SELECT COUNT(*) FROM customers' },
        'qb_data_size_retriever',
        QueryType.RETRIEVE,
        1,
        mockResponse
      );

      expect(MockedQBDataSizeRetriever).toHaveBeenCalled();
      expect(mockResponse.status).toHaveBeenCalledWith(200);
      expect(mockResponse.json).toHaveBeenCalled();
    });

    it('should handle complete workflow for data schema retriever', async () => {
      const wrapper = new TCWrapperBackend(BigInt(123), mockQBOProfile);
      
      await wrapper.run(
        'test-tool-call-id',
        { table_name: 'customers' },
        'qb_data_schema_retriever',
        QueryType.VALIDATE,
        1,
        mockResponse
      );

      expect(MockedQBDataSchemaRetriever).toHaveBeenCalled();
      expect(mockResponse.status).toHaveBeenCalledWith(200);
      expect(mockResponse.json).toHaveBeenCalled();
    });
  });
}); 